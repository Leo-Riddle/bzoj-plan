//最大权闭合子图
#include"iostream"
#include"stdio.h"
#include"stdlib.h"
#include"queue"
#include"string.h"
using namespace std;
const int oo=0x7f7f7f7f;
const int Maxn=6005;
const int Maxm=60005;
const int N=105;
struct node{int v,next,w;}e[Maxm];
int s,t,cnt=1;
int dis[Maxn],head[Maxn],a[N],d[N][N],id[N][N];
int flag[1005];
inline void Insert(int u,int v,int w)
{
	cnt++;
	e[cnt].v=v;
	e[cnt].w=w;
	e[cnt].next=head[u];
	head[u]=cnt;
}
inline void add(int u,int v,int w){Insert(u,v,w);Insert(v,u,0);}
queue<int>q;
bool spfa()
{
	memset(dis,-1,sizeof(dis));
	while(!q.empty())q.pop();
	q.push(s),dis[s]=0;
	while(!q.empty())
	{
		int x=q.front();q.pop();
		for(int i=head[x];i;i=e[i].next)
			if(dis[e[i].v]==-1&&e[i].w)
			{
				dis[e[i].v]=dis[x]+1;
				q.push(e[i].v);
			}
	}
	return dis[t]!=-1;
}
int dfs(int x,int low)
{
	int used=0,flow;
	if(x==t||!low)return low;
	for(int i=head[x];used<low&&i;i=e[i].next)
		if(e[i].w&&dis[e[i].v]==dis[x]+1)
		{
			if(flow=dfs(e[i].v,min(e[i].w,low-used)))
			{
				e[i].w-=flow;
				e[i^1].w+=flow;
				used+=flow;
			}
			if(used==low)return low;
		}
	if(!used)dis[x]=-1;
	return used;
}
int main()
{
	//freopen("text.in","r",stdin);
	int n,m,tmp=2,suma=0,flow=0;scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	s=1,t=Maxn-100;
	for(int i=1;i<=n;i++)
		for(int j=i;j<=n;j++)
			scanf("%d",&d[i][j]),id[i][j]=tmp++;
	for(int i=1;i<=n;i++)
	{
		if(!flag[a[i]])add(tmp++,t,m*a[i]*a[i]),flag[a[i]]=tmp-1;
		add(id[i][i],flag[a[i]],oo);
	}
	for(int i=1;i<=n;i++)
		for(int j=i;j<=n;j++)
		{
			int x=d[i][j];//printf("%d",x);
			if(i==j)x-=a[i];
			else add(id[i][j],id[i][j-1],oo),add(id[i][j],id[i+1][j],oo);
			if(x>0)suma+=x,add(s,id[i][j],x);
			else add(id[i][j],t,-x);
		}
	while(spfa())flow+=dfs(s,oo);
	printf("%d",suma-flow);
	return 0;
}
